1/9/2023
  Lambdas might be implementable as 'classes'
  that is we simply generate an 'anonymous'
  structure which records the arguments to
  the function and pass that in as an optionally
  invisible this pointer. Thus when we call said lambda
  it's body is implemented such that all
  arguments are retrieved through the pointer
  to the argument structure. then if each lambda
  still has the same signature of [void*(*)(void*)]
  we can imagine containers holding pointers to lambdas.
  (though each lambda within a given container must
  follow the rules of the given container.)

  okay hold up, what is to stop us from using the C
  calling convention as is, and simply representing
  lambda literals as structure types with a function
  pointer of the lambda type as the first member plus
  each argument of the lambda as each subsequent member?
  we can call that structure type a closure.
  then they are first class values exactly how structure
  types already are first class values.
  we could make an array of different lambdas as long as they had
  the same type, because in that case the structure types
  would by definition work out to the same structure
  type, just with a different address for the function,
  and we can already store heterogenous types in structure
  types. Also function calls work given a pointer to the
  closure structure, they can call through the function
  pointer, and retrieve all of the necessary values via
  the structure object at the call site. (note this does
  a bit of extra work over direct calls, but you get more
  flexibility via the closures being first class),
  this also doesn't stop us from passing a secret this
  pointer in addition, which allows us to lower self 
  recursive calls into a call through the closure's 
  function pointer. 

  oh, but then what is a function pointer? because we just gave ourselves
  a choice, either a pointer to a closure, or the function pointer
  within the closure. I mean, given that you have access to more
  information via a pointer to the closure I like that more.

  we can support the case of an empty pointer by making all pointer types
  optional types. and we can easily construct a closure type for any regular 
  function. which allows one to pass regular functions as values.
  additionally, since we can easily lower partial binding into struct access,
  we can support partial application of both lambda's and regular functions.
  As long as we accept that there is a value representing that particular 
  partial application created at that momement, and then destroyed like any 
  other temporary value. Thus that value must be immediately used (like it 
  is when you pass a function as a value (partial application providing zero 
  arguments)) or that value must be assigned to a local variable.
  (or assigned to some dynamic memory)

  we are prevented because of the type narrowing that happens during partial application.
  c++ solves this with the explicit capture list.

  if we could come up with a structure which could represent a closure around 
  a function of arbitrary type which could be applied systematically 
  without change to the underlying code which performs the application, then 
  we could imagine a proper semanitic to the situation where a larger function type 
  is partially applied down to a smaller function type, then it could be passed 
  to a function as an argument, and that inner functions call site would be able to 
  apply the passed closure.

  so what if instead of simply storing a struct with all of the arguments plus 
  the function pointer itself, you also store a pointer to that struct.
  then when any call site wants to pass the arguments it can simply pass that pointer,
  thus any call site can make use of only the first two members of the struct.

  in C it might be:

  int f(int a, int b) { return a + b; }

  typedef int (*f_pointer)(int, int);

  typedef struct closure_f_data {
    f_pointer ptr;
    int a;
    int b;
  } closure_f_data;

  typedef struct closure_f {
    f_pointer function_ptr;
    closure_f_data *args;
    closure_f_data data;
  } closure_f;

  

