

/*
maybe it actually makes more sense to consider a lambda literal
and a lambda definition, and make the definition a llvm::Function, and
thus access it's definition through this Lambda literal object
which we store in our symbol table, when we consider a statement
which stores a lambda, we store a lambda-literal. the implementation
of the lambda does still live in a single place however. this is more
 in the way/vein of
how we conceive of binops currently. and actually, now that
i think about it a bit more, its also like interning, we
only have the one codegen routine, and then what we pass around
is a pointer to that function/type/binop-codegen. then,
since we known each of the functions/types/binop-codegen-functions
is uniqued, we can treat the pointer as if it were a copy of
the function/type/binop-codegen-function that it is reffering
to. TL;DR, a procedures name decomposes to a pointer to the procedure
with type equivalent to the pointee. however when we store a procedure
we also need to store any closed over values, and any already bound
objects as well. closed over values are captured at the time that
the lambda is textually created within it's defining procedure.
a top level procedure definition doesn't need to capture any
globals it references, because a globals lifetime is already managed by
the program. also any globals that are referenced are necessarily
already constructed by the time that we enter any procedure call.
also, globals addresses are known at compile time, so any
procedure can be generated with the address stored as a local
value. in a register or in the constant data of the instructions.
all of this means that if a procedure is capturing data by-value, it
is doing it with locally stored data of the procedure the closure
is defined within. this means that within the body of the defining
procedure, textually, we can observe the definition point of the procedure.
naturally the code of the procedure will already have been generated
by the time we are running the enclosing procedure, however
the definition point still sit's between a few instructions (again, remember
i am talking about the text entered by the programmer and it's alignment
with the code generated by the compiler.), now
to make it natural for the programmer, this definition point is the
exact point in time where we want to capture any local values which
may exist up to this point. this maintains the natural flow of
definitions we have come to expect of C like languages.
i feel no need to revisit this idea. information in pink flows
from right to left, top to bottom, innermost to outermost

and we consider a literal object that can be stored in the
Ast to simply hold a reference to the actual object.
like Binop, is to BinopTable, and BinopCodegenTable.
in this case the llvm::Function. this separation allows
us two codegen procedures, one to generate the definition of
a procedure within LLVM itself, and thus add it to the
module to be able to be called. and the second to generate
the code which conceives of the function being stored on the
stack (with or without pre-bound arguments)

defining a local procedure should amount to defining a
local-scope-visible, module-scoped-definition, which otherwise
works just like a regular procedure. we store it in the module
of the procedure the inner procedure is defined in, and only
allow it to be called within the scope it is defined in.
returning the locally defined procedure would allow
others to call into what is essentially 'private' code,
except they can only do so after first calling the public generator
procedure which returns the private procedure as a value.
this is analagous to the idea of using a public linkage
interface method, which behind the scenes calls a private linkage
more primative method which does part-of/all-of the real work
of the publicly facing procedure.

*/

/*
  Order of Operations with the lambda is
  parser constructs passing in pink stuff,
    what we parsed of the formal arguments,
    and what we parsed as the body.
  repl calls the static analyzer to double check,
    this has the additional effect of filling out
    the FunctionType* record. (memory is managed by
    llvm itself which is why we use bare pointers.)
  repl calls codegen to get an interpretable sequence
    of instructions, this has the effect of filling out
    the Function* record with a valid body.

  we want to store Lambda's in symboltables such that we can
  later evaluate defined lambda's, except llvm already provides
  a symboltable which maps names to global values, of which functions
  are global, in the module sense at least, depends upon linkage from there.
  so i would rather not repeat logic if i don't need to.
  however, this means waiting until binding time to actually define the
  procedure, because llvm binds the function in the modules
  symboltable at time of definition! and again, using our symbol-table
  to bind functions feels like a repeat of the logic within llvm.

  so, maybe we lean more on this idea of our language only storing references
  to procedures within the 'text' of the program as it were. and functions,
  and likewise other global constants, are exclusively referenced by their
  address within the text. when we consider the bind operator, we are
  considering the act of binding a name to a value for sure, however
  we are also considering the first construction of an object as well.
  either the default construction or some specified construction.
  this is similar to the idea of the first copy-assignment as well.
  because we are truly marking out some specific region in memory
  according to some provided type, and then assigning it a name.

  local variables need to be able to have more than one copy floating
  around and have that be fine. which is why integers are so nice,
  everyone can have a copy of whatever number they want and nobody's
  number affects anyone elses number. what is really being passed around
  is the representation of a number. so, what can be passed around of
  functions is a representation of a function. it just so happens that
  functions are always uniqued within the context of a program. this means that
  what bind bind's to the name is not the definition of the
  function itself, but a datum which represents the defintion of
  the function. we consider the two distinct from eachother.
   if we consider now a global variable that has been intialized
  to hold another function, what just happened is that they are holding a
  reference to the function, plus some pointers for potential data.
  this on it's face allows a programmer to alias procedures by simply
  assigning a variable to the name of the procedure.
  this has the same effect that defining the procedure had in the first
  place, it is simply the case that a normal procedure declaration is
  also the place where we associate the procedures body with it's
  type. these two things are what we give a name, simultaneously with a single
  statement. the name and it's memory hold only a reference to the body located
  elsewhere. then we can consider copying, assigning, and passing around this
  reference to the procedure. when two functions apply the procedure,
  they are both doing so at separate times. which means that we are really
  talking about the flow of control entering from more that one point.
  (we can imagine the path of the flow of control for the full program must
  allow one to walk from the first call point of the procedure to the second
  call point of the procedure.)
   ((of course this is violated with multiprocessing,
  however we haven't gotten there yet.))

  this in essence makes the definition of a procedure completely independant of the nameing
  of the procedure, and thus the binding within our local symboltable,
  and thus the memory we are conceiving of allocating for the variable
  which has the name of the function, which is only ever the address of the definition,
  plus some extra data for bookkeeping.

  i think this means that lambdas are flyweights of their corresponding
  function definition. (a little bit larger than a bare function pointer,
  because we are storing the partially applied bindings as by-value copies within the
  lambda structure itself, and we also need to store by-value any values
  which are closed over at definition time by the procedure definition.)

  in this way we can consider a function alias which at the same time
  also provides a binding for one or more of the arguments expected by
  the function we are aliasing. think printf and fprintf, gets and fgets.
  except that this functionality is provided by the interoperation of the more basic components
  of the language, namely binding and partial application.


*/

/*
  x := \y:Int => y + y

  // in pseudocode which matches the calling sequence of the
  // ast nodes:
  bind(x, lambda(y:Int, y + y))

  we don't know the name of the function we just described
  until we enter the bind node of the Ast.
  this means we do not have all of the information required by
  the construct and insert this function into the module with
  such and such linkage into the module until
  we encounter the function declaration in some outer bind expression.

  this is because calling
  Function::Create, does two things simultaneously, it builds
  the function literal, and it binds the name of the procedure
  to the function literal in the modules symbol table.

  and within the grammar of the language those two things are separate.

  ':=' bind modifies the symbol table,
  appending in a new value.
  and the '\' symbol signals that
  a lambda definition is going to occur.

  on it's face i think this means that bind needs to handle
  each possibility with a switch, that we then  place the call to
  Function::Create within. and we signal that this needs to happen
  by returning a lambda object.

  when the parser parses a traditional function definition it can call
  the Function::Create routine directly.

  what then about lambda objects which are created as values within expressions,
  meant to be used a subcomponents to a larger expression, where we the
  programmer don't care about holding a reference to the procedure one we
  are done using it. or, where we the programmer want to return a reference to
  an inner definition of a procedure?

  x := (\x:x+x) 2

  or:

  y := f (\x:x*x) 2

  so i suppose given all of the above discussion
  the sequence of operations would be

  parse a bind definition
    parse a lambda definition
    construct a Lambda object
  construct a Bind name to Lambda object operation.

  which is distinct from when we
  build a bind a name to a constant value operation,
  build a bind a name to a global variable operation,
  build a bind a name to a local variable operation,
  build a bind a name to the result of evaluating this sequence
    of instructions with some result type operation.

  and all of that can be distinct from parse and build
  a procedure definition, which includes the name we are
  binding to.
-------

all of this boild down to,

  (\x:Int=>x) describes a procedure definition,
  and it results in a temporary value which is
  a function pointer and a binding set which is
  empty. this value can then be applied to actual
  arguments, which results in the computer binding
  the actual argument to the formal argument, and
  jumping into the procedure, which does it's work,
  and jumps back to the call point with the link,
  while returning a value in the process. the place
  just past the call point unbinds the argument,
  and then we continue with the functions definition.

*/

#pragma once
#include <vector>
#include <utility>
#include <string>
#include <memory>

#include "llvm/IR/Type.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"

#include "Location.hpp"
#include "Judgement.hpp"
#include "Environment.hpp"
#include "Argument.hpp"
#include "Object.hpp"


/*
  llvm is going to be treated like a
  function interner. our programming
  language is going to describe all
  applications in terms of interned
  functions. functions can be treated
  like objects in the sense that
  we can capture a particular application
  of a procedure with an object,
  however the definition of the procedure itself
  happens once and only once.

  so an object which represents a lambda needs to
  communicate it's definition from the parser to
  the function interner/definer, llvm.

  okay, so when we encounter a lambda definition,
  we need to come up with a garunteed unique lambda
  name, and it needs to be added to the module with
  the name so we can generate calls to it.

  we need to build the function the lambda describes
  with llvm, in the codegen function. then what
  we return out of the codegen function, that is the value
  we return to represent the function is itself one
  of these function-objects. thus a Lambda literal
  does two things, defines a procedure, produces a
  temporary value representing the function that can be
  captured by the local scope, and thus work done with it.
  (this temporary value is the same thing that would be
   created if the user were to request an already bound
   procedure to be stored)
  then, if the user is
  applying this function object we can build
  an apply from the function object, by passing the
  imlicit arguments to the procedure, and passing
  the supplied actual arguments to the procedure,
  which come together to make up the full argument
  list.

*/

/*
  represents the definition of an anonymous function
  within our grammar.
*/
class Lambda : public Object
{
private:
  llvm::FunctionType* llvm_function_type;
  llvm::Function*     llvm_function_literal;
  std::vector<Argument> formal_args;
  std::unique_ptr<SymbolTable> symbols;
  std::shared_ptr<Ast> body;

  static std::string Gensym(const Environment& env);

  virtual Judgement GetypeV(const Environment& env) override;
public:
  Lambda(const Location& loc, std::vector<Argument>& formal_args, SymbolTable* outer_symbols, std::shared_ptr<Ast> body);
  virtual ~Lambda() = default;

  virtual std::shared_ptr<Lambda> Clone() override;
  virtual std::string ToString() override;

  /*
    After a call to Getype,
    the FunctionType* can be filled in

    After a call to Codegen,
    the Function* can be filled in.
  */

  // the real trick to codgen with LLVM
  // is to notice that we are maintaining
  // our symboltable with the bindings
  // contained within local scopes.
  // these hold llvm::Value*'s that can
  // be passed into futher instructions
  // that we tell llvm to build- and that is
  // what manages the flow of information
  // from one usage of a value to the next.
  // an instruction is built by passing in
  // the Value's it operates upon. that instruction
  // then becomes a User of that Value.
  virtual Judgement Codegen(const Environment& env) override;
};
