

/*
maybe it actually makes more sense to consider a lambda literal
and a lambda definition, and make the definition a llvm::Function, and
thus access it's definition through this Lambda literal object
which we store in our symbol table, when we consider a statement
which stores a lambda, we store a lambda-literal. the implementation
of the lambda does still live in a single place however. this is more
 in the way/vein of
how we conceive of binops currently. and actually, now that
i think about it a bit more, its also like interning, we
only have the one codegen routine, and then what we pass around
is a pointer to that function/type/binop-codegen. then,
since we known each of the functions/types/binop-codegen-functions
is uniqued, we can treat the pointer as if it were a copy of
the function/type/binop-codegen-function that it is reffering
to. TL;DR, a procedures name decomposes to a pointer to the procedure
with type equivalent to the pointee. however when we store a procedure
we also need to store any closed over values, and any already bound
objects as well. closed over values are captured at the time that
the lambda is textually created within it's defining procedure.
a top level procedure definition doesn't need to capture any
globals it references, because a globals lifetime is already managed by
the program. also any globals that are referenced are necessarily
already constructed by the time that we enter any procedure call.
also, globals addresses are known at compile time, so any
procedure can be generated with the address stored as a local
value. in a register or in the constant data of the instructions.
all of this means that if a procedure is capturing data by-value, it
is doing it with locally stored data of the procedure the closure
is defined within. this means that within the body of the defining
procedure, textually, we can observe the definition point of the procedure.
naturally the code of the procedure will already have been generated
by the time we are running the enclosing procedure, however
the definition point still sit's between a few instructions (again, remember
i am talking about the text entered by the programmer and it's alignment
with the code generated by the compiler.), now
to make it natural for the programmer, this definition point is the
exact point in time where we want to capture any local values which
may exist up to this point. this maintains the natural flow of
definitions we have come to expect of C like languages.
i feel no need to revisit this idea. information in pink flows
from right to left, top to bottom, innermost to outermost

and we consider a literal object that can be stored in the
Ast to simply hold a reference to the actual object.
like Binop, is to BinopTable, and BinopCodegenTable.
in this case the llvm::Function. this separation allows
us two codegen procedures, one to generate the definition of
a procedure within LLVM itself, and thus add it to the
module to be able to be called. and the second to generate
the code which conceives of the function being stored on the
stack (with or without pre-bound arguments)

defining a local procedure should amount to defining a
local-scope-visible, module-scoped-definition, which otherwise
works just like a regular procedure. we store it in the module
of the procedure the inner procedure is defined in, and only
allow it to be called within the scope it is defined in.
returning the locally defined procedure would allow
others to call into what is essentially 'private' code,
except they can only do so after first calling the public generator
procedure which returns the private procedure as a value.
this is analagous to the idea of using a public linkage
interface method, which behind the scenes calls a private linkage
more primative method which does part-of/all-of the real work
of the publicly facing procedure.

*/

/*
  Order of Operations with the lambda is
  parser constructs passing in pink stuff,
    what we parsed of the formal arguments,
    and what we parsed as the body.
  repl calls the static analyzer to double check,
    this has the additional effect of filling out
    the FunctionType* record. (memory is managed by
    llvm itself which is why we use bare pointers.)
  repl calls codegen to get an interpretable sequence
    of instructions, this has the effect of filling out
    the Function* record with a valid body.

  we want to store Lambda's in symboltables such that we can
  later evaluate defined lambda's, except llvm already provides
  a symboltable which maps names to global values, of which functions
  are global, in the module sense at least, depends upon linkage from there.
  so i would rather not repeat logic if i don't need to.
  however, this means waiting until binding time to actually define the
  procedure, because llvm binds the function in the modules
  symboltable at time of definition! and again, using our symbol-table
  to bind functions feels like a repeat of the logic within llvm.

  so, maybe we lean more on this idea of our language only storing references
  to procedures within the 'text' of the program as it were. and functions,
  and likewise other global constants, are exclusively referenced by their
  address within the text. when we consider the bind operator, we are
  considering the act of binding a name to a value for sure, however
  we are also considering the first construction of an object as well.
  either the default construction or some specified construction.
  this is similar to the idea of the first copy-assignment as well.
  because we are truly marking out some specific region in memory
  according to some provided type, and then assigning it a name.

  local variables need to be able to have more than one copy floating
  around and have that be fine. which is why integers are so nice,
  everyone can have a copy of whatever number they want and nobody's
  number affects anyone elses number. what is really being passed around
  is the representation of a number. so, what can be passed around of
  functions is a representation of a function. it just so happens that
  functions are always uniqued within the context of a program. this means that
  what bind bind's to the name is not the definition of the
  function itself, but a datum which represents the defintion of
  the function. we consider the two distinct from eachother.
   if we consider now a global variable that has been intialized
  to hold another function, what just happened is that they are holding a
  reference to the function, plus some pointers for potential data.
  this on it's face allows a programmer to alias procedures by simply
  assigning a variable to the name of the procedure.
  this has the same effect that defining the procedure had in the first
  place, it is simply the case that a normal procedure declaration is
  also the place where we associate the procedures body with it's
  type. these two things are what we give a name, simultaneously with a single
  statement. the name and it's memory hold only a reference to the body located
  elsewhere. then we can consider copying, assigning, and passing around this
  reference to the procedure. when two functions apply the procedure,
  they are both doing so at separate times. which means that we are really
  talking about the flow of control entering from more that one point.
  (we can imagine the path of the flow of control for the full program must
  allow one to walk from the first call point of the procedure to the second
  call point of the procedure.)
   ((of course this is violated with multiprocessing,
  however we haven't gotten there yet.))

  this in essence makes the definition of a procedure completely independant of the nameing
  of the procedure, and thus the binding within our local symboltable,
  and thus the memory we are conceiving of allocating for the variable
  which has the name of the function, which is only ever the address of the definition,
  plus some extra data for bookkeeping.

  i think this means that lambdas are flyweights of their corresponding
  function definition. (a little bit larger than a bare function pointer,
  because we are storing the partially applied bindings as by-value copies within the
  lambda structure itself, and we also need to store by-value any values
  which are closed over at definition time by the procedure definition.)

  in this way we can consider a function alias which at the same time
  also provides a binding for one or more of the arguments expected by
  the function we are aliasing. think printf and fprintf, gets and fgets.
  except that this functionality is provided by the interoperation of the more basic components
  of the language, namely binding and partial application.


*/

/*
  x := \y:Int => y + y

  // in pseudocode which matches the calling sequence of the
  // ast nodes:
  bind(x, lambda(y:Int, y + y))

  we don't know the name of the function we just described
  until we enter the bind node of the Ast.
  this means we do not have all of the information required by
  the construct and insert this function into the module with
  such and such linkage into the module until
  we encounter the function declaration in some outer bind expression.

  this is because calling
  Function::Create, does two things simultaneously, it builds
  the function literal, and it binds the name of the procedure
  to the function literal in the modules symbol table.

  and within the grammar of the language those two things are separate.

  ':=' bind modifies the symbol table,
  appending in a new value.
  and the '\' symbol signals that
  a lambda definition is going to occur.

  on it's face i think this means that bind needs to handle
  each possibility with a switch, that we then  place the call to
  Function::Create within. and we signal that this needs to happen
  by returning a lambda object.

  when the parser parses a traditional function definition it can call
  the Function::Create routine directly.

  what then about lambda objects which are created as values within expressions,
  meant to be used a subcomponents to a larger expression, where we the
  programmer don't care about holding a reference to the procedure one we
  are done using it. or, where we the programmer want to return a reference to
  an inner definition of a procedure?

  x := (\x:x+x) 2

  or:

  y := f (\x:x*x) 2

  so i suppose given all of the above discussion
  the sequence of operations would be

  parse a bind definition
    parse a lambda definition
    construct a Lambda object
  construct a Bind name to Lambda object operation.

  which is distinct from when we
  build a bind a name to a constant value operation,
  build a bind a name to a global variable operation,
  build a bind a name to a local variable operation,
  build a bind a name to the result of evaluating this sequence
    of instructions with some result type operation.

  and all of that can be distinct from parse and build
  a procedure definition, which includes the name we are
  binding to.
-------

all of this boild down to,

  (\x:Int=>x) describes a procedure definition,
  and it results in a temporary value which is
  a function pointer and a binding set which is
  empty. this value can then be applied to actual
  arguments, which results in the computer binding
  the actual argument to the formal argument, and
  jumping into the procedure, which does it's work,
  and jumps back to the call point with the link,
  while returning a value in the process. the place
  just past the call point unbinds the argument,
  and then we continue with the functions definition.

*/

#pragma once
#include <vector>
#include <utility>
#include <string>
#include <memory>

#include "llvm/IR/Type.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"

#include "Location.hpp"
#include "Judgement.hpp"
#include "Environment.hpp"
#include "Ast.hpp"


/*
  llvm is going to be treated like a
  function interner. our programming
  language is going to describe all
  applications in terms of interned
  functions. functions can be treated
  like objects in the sense that
  we can capture a particular application
  of a procedure with an object,
  however the definition of the procedure itself
  happens once and only once.

  so an object which represents a lambda needs to
  communicate it's definition from the parser to
  the function interner/definer, llvm.

  okay, so when we encounter a lambda definition,
  we need to come up with a garunteed unique lambda
  name, and it needs to be added to the module with
  the name so we can generate calls to it.

  we need to build the function the lambda describes
  with llvm, in the codegen function. then what
  we return out of the codegen function, that is, the value
  we return to represent the function is itself one
  of these function-objects. thus a Lambda literal
  does two things, defines a procedure, and produces a
  temporary value representing the procedure that can be
  captured by the local scope, and thus work done with it.
  (this temporary value is the same thing that would be
   created if the user were to request an already bound
   procedure to be stored)
  then, if the user is
  applying this function object we can build
  an apply from the function object, by passing the
  imlicit arguments to the procedure, and passing
  the supplied actual arguments to the procedure,
  which come together to make up the full argument
  list.

  because we are always formally building applications
  from closure objects, we can consider only a single
  form of application. otherwise we would need a form
  for closures and a form for procedure calls to not
  closures. we can consider applications that
  provide all formal arguments to be equivalent to
  C procedure calls, and we can optimize them the
  same, (i think that's how it works at least)

  thereform only exactly where we need to, will the
  compiler emit a heap allocation.

  now, do we place these closures into an invalid
  state after their frist call? this makes storage
  of closures inconveinent, as we need to rebuild
  everytime we apply if we want to use the stored closure
  again, so i think this means we want to accept whatever
  semantics arise from the opposite choice, namely
  that we free them only when absolutely necessary.
  for a procedure that is local to a scope and never
  has it's lifetime extended via. returning the procedure
  as the result value, then we can insert a free of the
  closure at the end of the scope, then each call to
  this procedure will allocate a proper closure, and then
  deallocate it. (and if the lambda is used exclusively
  in this way, then we can garuntee that the defining
  scope will always be alive during the evaluation of
  the lambda, and more optimizations can be used.)
  (we could elide by-value captures/arguments and use stack
   addresses to get to constant local data for instance.
   i.e. in this case we can consider the implicit capture to
   be equivalent to a dynamically scoped reference.)

  should the lifetime be extended, by either returning
  the closure as a result, or storing the closure in
  dynamic memory, the closures lifetime is extended to be
  equivalent to the lifetime of the storage cell.

  (perhaps we say, a reference to the object is non-owning?
   then storing a reference to a closure in dynamic memory
   would -have- to be an error, because the lifetime is
   explicitly not extended, and thus the reference would be
   pointing to garbage as soon as the local scope surrounding
   the assignment statement was fully evaluated.)

  if we receive some dynamic memory and thus take ownership
  of it's memory, (by the nature of us having the only living
  reference to the closure after the defining scope exits)
  then unless the lifetime is extended we are free to
  free the closure at the end of this scope. and again
  the only current lifetime extension methods are
  return values, and dynamic storage.
  (if we conside an array of lambda literals, we are considering
   an array of pointers to dynamic memory. but conceptually
   we are storing the procedure literal as a 'value' within the
   array. so the lifetime of the pointer is semantically equal
   to the lifetime of it's referent memory, it is in essence an
   owning pointer. sort of equivalent to a unique_ptr.)

  we can thus accurately, implicitly allocate and free lambda objects,
  and truly all objects that are dynamically allocated
  as long as their lifetimes are only ever extended via return
  values. because then it becomes a question of if the dynamic
  value is being returned, or being assigned into a value that
  is being returned. (we kinda already know which values we are
  assigning to the return value, as it's explicit/implicit in the
  syntax of the language itself.)

  the only tricky part is if the lifetime is extended by means of
  assignment into other dynamic memory. semantically we are talking
  about the same thing, this dynamic memory now manages the lifetime
  of the memory of the closure. this seems to only add a single
  layer of scomplication, but it actually adds an infinite set of
  layers of complexity, in that we can consider assigning this
  reference to dynamic memory into arbitrarily many other dynamic
  allocations, and then the memory has to have it's lifetime tied
  to all instances of a reference to it. which again, could be
  any number. so, truly to model this, we could use the semantics
  of a shared_ptr. when we are in the case of extension via return
  values, the shared_ptr will fluxuate between one and two references
  to the closure as we walk from getting the first reference, to
  assigning it to a return location, and having two references, to
  then retuning out and freeing the first reference, back to one living
  reference. and so on until we enter the case where we don't store
  another reference whereby on the final deallocation of the reference
  we are in the case where we dont have any living reference and we can
  free the closure. and shared_ptr was built explicitly for the case where
  we have arbitrarily many dynamic references, because each assigned reference
  increments the number of shared_ptrs to the same memory, and each
  free of the other dynamic reference similarly decrements the number
  of shared references, and so we can accurately track the number of
  living references and free when it reaches zero. which is thus allowed
  to either happen, or never happen depending upon the syntax entered by
  the programmer (which is good, because we want to expose engineering choices)

  there is a wrench in this plan in that shared_ptrs are built atop
  the OOP structures of c++ and we have no such structures defined.
  however, we do know that many of the structures of OOP are built
  atop the fact that all types can be built by calling a procedure
  with a knowable name to build values of said type, (constructors),
  and a procedure that has a knowable name for destroying values of
  said type (destructors). if we simply implicitly define these procedures
  for all types within the programming language we will have access
  to the primitive semantics atop which we can express uniform construction
  and destruction. the big thing with OOP is defining objects with members
  who are also objects, via inheritance, which can then be leveraged to
  define polymorphic procedures. however polymorphic calling, and
  defining objects with inheritance do not necessarily have to go together,
  as was proven by CLOS. so, what if we consider instead that any type can be
  built by a special procedure which is named the same thing as the type itself,
  which takes by default an argument list which is equivalent to it's member
  list. (this will be expanded in the future to a programmer defined overload set.)
  and destroyed via a procedure with a name that has a similar naming
  convention. both take the object to be built as a reference parameter in
  the first position. thus we can call this procedure to build objects
  on the stack or the heap.

  and we can define constructors so that they call the constructors
  of the parent type, before they call the constructors of the
  child type, when we define single inheritance for our types.


*/

/*
  represents the definition of an anonymous function
  within our grammar.
*/

namespace pink {

class Lambda : public Ast
{
private:
  // ret, arg0, arg1, ..., argN
  // std::vector<llvm::Type*> presented_fn_type;
  llvm::AttributeList   lambda_attributes;
  std::vector<std::pair<InternedString, llvm::Type*>> formal_arguments;
  std::unique_ptr<SymbolTable> symbols;
  std::shared_ptr<Ast> body;

  virtual Judgement GetypeV(const Environment& env) override;
public:
  Lambda(const Location& loc, std::vector<std::pair<InternedString, llvm::Type*>>& formal_args, SymbolTable* outer_symbols, std::shared_ptr<Ast> body);
  virtual ~Lambda() = default;

  static bool classof(const Ast* ast);

  virtual std::shared_ptr<Lambda> Clone() override;
  virtual std::string ToString() override;

  virtual Judgement Codegen(const Environment& env) override;
};

}
