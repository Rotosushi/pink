so, the coarse grained view of usage is:

construct a LLVM module. (and destroy after using.)
(or use the global LLVM module, which i would hazard to guess
 is statically allocated?)

if we are interpreting we are working over a basic block or a module?
where we traverse the ast and construct a set of LLVM instructions
which perform the actions we read from the ast.
then we JIT the series of instructions.

what's confusing is there is an Execution Engine,
an Interpreter, a JIT compiler, and an MCJIT compiler?

also also, if we use a module during interpretation do we
constantly reinvoke each statement as a new main? then
pink modules could be brought in via a single statement.
the other choice that seems to make sense is to fill in a
basic block, JIT it and interpret? idk.


however, compilation makes total sense from a coarse
grained perspective. we open a file containing pink code,
and a main entry point
build a module by appending function bodies and global data
to the module and then we turn that module into native code
with a main entry point, place it all in an ELF file and
then it can be run independently.

if more than one file is specified each gets their own module
and then we can bring each module into a single source and then
turn that into native code and place it into an ELF file with a
main and then were golden.

-------------------------------------------------------------------------------

additionally, TypeInterner can be modified to be a wrapper around the LLVM
TypeInterner, (which is stored within the LLVMModule being used for compilation)
TypeLiteral becomes a wrapper for a (LLVMTypeRef)

I think Object becomes a wrapper for LLVMValueRef,
yep, and so does a bunch of other stuff i think,
including so far Judgement, and every object representing
a value within our language.




so, we as an interpreter we are operating over a single instruction.
when we expand the language to include the sequence grapheme we -have-
to operate over a basic-block at a minimum, and when we compile one or
more modules we have to operate over modules.

we construct instructions using the
LLVMBuild* family of procedures.
these return values of kind LLVMValueRef
with an instance of
