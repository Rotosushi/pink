a polymorphic type on the lhs of an application is okay,
a polymorphic type on the rhs of an application is a polymorphic definition,
a monotonic type on the rhs and a polymorphic type on the lhs means we want
to ask the polymorphic type if it can be instanced with this monotonic type,
which brings the problem to, how to we connect the polymorphic type (a single thing)
to each correct polymorphic procedure which needs to be asked the question.

my first instinct is to hold a PolyLambda* within the structure representing
Poly Type Literals, (like how we have a location association for literals, even
though we intern the exact representation) this means assigning this pointer at
the time at which we generate the polymorphic type judgement from the polymorphic
lambda. (because only terms with no type annotation are declared to be polymorphic
we can say that a polymorphic judgement means that a polylambda object generated that
type. either we saw the polylambda object immediately, or it was bound to a name in
the environment. but that is the only location we will observe the polymorphic type.
so when we encounter the polymorphic object and can say, "oh, this term has polymorphic
type" we are also in a position to hold the address of the object which generated the
polymorphic type, and pass that in to a procedure which knows how to ask that object if
it can be instanced with the type we also observed.


TL;DR this method of polymorphism is undecidable! and i -know- that now!
woohoo i learned something!! this method works great as long as you are talking
about concrete terms being applied to Polymorphic terms. it falls apart
when we consider building polymorphic terms out of polymorphic terms.
once we do this we loose any ability to distinguish between which polymorphic
procedure is bound to a particular concrete implementation. the information
required to make this choice correctly depends upon what procedure the
programmer intended to call at the application site, which requires us to
distinguish between a set of bound terms each of which is necessarily a
polymorphic application. when we subsequently try to apply this Procedure
giving it a static type, there isn't a difference between polymorphic
procedures.

however, if we ask the programmer to specify the types explicitly, and
we add in another term which allows this annotation to occur, we essentially
have reinvented Templates. so we might as well just go with a template
implementation right off the bat and base it off of someone elses hard work
of solving this problem. the other choice is to pivot to ML style polymorphism
which allows for us to write in fully untyped terms. which is pretty cool
i must admit. however, it may cloud our intuition behind implementation
if we consider this a successor language to C. I honestly don't really
know how bad it would be, considering we usually know the types.
it might be just a different mode of thinking. either way, this
is being delayed until after we can emit assembly for the simply
typed lambda calculus. (plus algebraic data types.)
