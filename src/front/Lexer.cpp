/* Generated by re2c 3.0 on Tue Jul 26 11:47:54 2022 */
#line 1 "src/front/Lexer.re"

#include "front/Lexer.h"

namespace pink {
    Lexer::Lexer()
        : loc(), buffer()
    {
        end = cursor = marker = token = buffer.end();
    }

    Lexer::Lexer(std::string& buf)
        : loc(), buffer(buf)
    {
        end = buffer.end();
        cursor = marker = token = buffer.begin();
    }

    std::string& Lexer::GetBuf()
    {
      return buffer;
    }

    void Lexer::SetBuf(std::string& buf)
    {
        buffer = buf;
        end = buffer.end();
        cursor = marker = token = buffer.begin();
    }

    void Lexer::AppendBuf(std::string& buf)
    {
      // this procedure modifies the buffer we are currently parsing 
      // by appending the text passed onto it.
      // normally this is inadvisable, because if the string being 
      // appened onto needs to reallocate its internal buffer to
      // accomidate the new characters then any iterators into 
      // said buffer will be invalidated, and we will not keep our 
      // location within the buffer. this is a problem, because we 
      // only want to add new text to lex, we don't want to destroy
      // our position within the array. so we can keep lexing where 
      // we left off. 
      // to solve this problem we are going to take advantage of the 
      // fact that when we perform the append operation, the original 
      // text, and position of said text within the new buffer will 
      // be identical to what it was before the append operation.
      // this is because the append operation does not modify the 
      // existing text, or its relative position within the buffer,
      // it only adds new text after the end.
      // thus if we store the distance that each iterator is into the 
      // current buffer, after the append, we can 'restore' the position 
      // of the iterators within the new buffer containing the 
      // old text and the appended new text.
      
      // save the relative offsets of each iterator.
      int cursor_dist = Distance(buffer, cursor);
      int marker_dist = Distance(buffer, marker);
      int token_dist  = Distance(buffer, token);
      
      buffer += buf; // perform the append operation, which may invalidate the iterators
      
      // construct new valid iterators, at their old relative offsets within the new string.
      end    = buffer.end();
      cursor = SeekIterator(buffer, cursor_dist);
      marker = SeekIterator(buffer, marker_dist);
      token  = SeekIterator(buffer, token_dist);
    }

    void Lexer::Reset()
    {
        buffer.clear();
        end = cursor = marker = token = buffer.end();
    }
    
    bool Lexer::EndOfInput()
    {
      return (end - cursor) == 0;
    }

    /*
        This routine works great for single line
        inputs, but should be tested against multi-line
        inputs for a more rigourous compiler. #TODO
    */
    void Lexer::UpdateLoc()
    {
    /*
        since token points to the beginning of the
        current token being lexed, and cursor points
        to the current position of the lexer,
        after a token has been lexed from the buffer,
        it sits between [cursor, token], and the
        string iterator operator -() lets us compute
        that distance in chars directly.

        theoretically we could swap string for wstring
        to support unicode. I think this would still
        work, but i'm not 100% sure about that.
    */
        size_t length = cursor - token;

        loc.firstLine   = loc.lastLine;
        loc.firstColumn = loc.lastColumn;

        for (size_t i = 0; i < length; i++)
        {
            if (token[i] == '\n')
            {
                loc.lastLine   += 1;
                loc.lastColumn += 1;
            }
            else
            {
                loc.lastColumn += 1;
            }
        }
    }

    int Lexer::Distance(std::string& buf, std::string::iterator it)
    {
      // the iterator points to somewhere in the array of characters,
      // the beginning of the buffer is somewhere in memory. since the 
      // data structure is a string, we know that the elements of memory 
      // between the beginning and it are also members of this string.
      // since the iterators are also just pointers, and pointers are 
      // just integers, we can subtract the farther point, it, from the 
      // closer point, buf.begin(), this results in the distance between the
      // two iterators. that is the number of characters within the string 
      // between the beginning and the iterator it.
      return it - buf.begin();
    }

    std::string::iterator Lexer::SeekIterator(std::string& buf, int distance)
    {
      // return an iterator into the string some distance into the string.
      return buf.begin() + distance;
    }


    /*
        token points to the beginning of the
        current token being lexed, and cursor points
        to the current position of the lexer,
        so the last token that was lexed is sitting
        between those two positions.

        Therefore we can use the string constructor
        taking a two iterators to construct the
        string from the characters from between that range.
    */
    std::string Lexer::yytxt()
    {
        return std::string(token, cursor);
    }

    Location Lexer::yyloc()
    {
        return loc;
    }


    /*
        These are the definitions of the parsing
        primitives that re2c uses, such that we
        can interoperate between c++ and re2c
        
        # TODO: i think this regex will allow for identifiers 
        	like: this-is-an-ident, follow-with-hyphen
        	but dissallow idents like:
        		-unop-application-not-an-ident,
        		binop-application-not-an-ident- more-text
        		 
        id=[a-zA-Z_]([-]?[a-zA-Z0-9_])*;
    */
    #line 192 "src/front/Lexer.re"


	// NOLINTBEGIN(cppcoreguidelines-avoid-goto)
	// re2c uses gotos to implement the lexer, as all of the 
	// gotos are from generated code, we are trusting re2c to 
	// use gotos in a safe and sane way here.
    Token Lexer::yylex()
    {
        while (1)
        {
            token = cursor;
         
            
#line 191 "src/front/Lexer.cpp"
{
	char yych;
	yych = *cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy2;
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '<':
		case '>':
		case '@':
		case '\\':
		case '^':
		case '|':
		case '~': goto yy4;
		case '(': goto yy6;
		case ')': goto yy7;
		case ',': goto yy8;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy9;
		case ':': goto yy11;
		case ';': goto yy13;
		case '=': goto yy14;
		case 'A':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		case 'B': goto yy19;
		case 'I': goto yy20;
		case 'N': goto yy21;
		case 'f': goto yy22;
		case 'n': goto yy23;
		case 't': goto yy24;
		case '{': goto yy25;
		case '}': goto yy26;
		default:
			if (end <= cursor) goto yy52;
			goto yy1;
	}
yy1:
	++cursor;
#line 229 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Error; }
#line 292 "src/front/Lexer.cpp"
yy2:
	yych = *++cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy2;
		default: goto yy3;
	}
yy3:
#line 228 "src/front/Lexer.re"
	{ UpdateLoc(); continue; }
#line 304 "src/front/Lexer.cpp"
yy4:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '<':
		case '=':
		case '>':
		case '@':
		case '\\':
		case '^':
		case '|':
		case '~': goto yy4;
		default: goto yy5;
	}
yy5:
#line 225 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Op; }
#line 328 "src/front/Lexer.cpp"
yy6:
	++cursor;
#line 219 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LParen; }
#line 333 "src/front/Lexer.cpp"
yy7:
	++cursor;
#line 220 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RParen; }
#line 338 "src/front/Lexer.cpp"
yy8:
	++cursor;
#line 214 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Comma; }
#line 343 "src/front/Lexer.cpp"
yy9:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy9;
		default: goto yy10;
	}
yy10:
#line 226 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Int; }
#line 362 "src/front/Lexer.cpp"
yy11:
	yych = *++cursor;
	switch (yych) {
		case '=': goto yy27;
		default: goto yy12;
	}
yy12:
#line 216 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Colon; }
#line 372 "src/front/Lexer.cpp"
yy13:
	++cursor;
#line 215 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Semicolon; }
#line 377 "src/front/Lexer.cpp"
yy14:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '<':
		case '=':
		case '>':
		case '@':
		case '\\':
		case '^':
		case '|':
		case '~': goto yy4;
		default: goto yy15;
	}
yy15:
#line 217 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Equals; }
#line 401 "src/front/Lexer.cpp"
yy16:
	yych = *++cursor;
yy17:
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy18;
	}
yy18:
#line 224 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Id; }
#line 474 "src/front/Lexer.cpp"
yy19:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'o': goto yy28;
		default: goto yy17;
	}
yy20:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'n': goto yy29;
		default: goto yy17;
	}
yy21:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'i': goto yy30;
		default: goto yy17;
	}
yy22:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'a': goto yy31;
		case 'n': goto yy32;
		default: goto yy17;
	}
yy23:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'i': goto yy34;
		default: goto yy17;
	}
yy24:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'r': goto yy35;
		default: goto yy17;
	}
yy25:
	++cursor;
#line 221 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LBrace; }
#line 522 "src/front/Lexer.cpp"
yy26:
	++cursor;
#line 222 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RBrace; }
#line 527 "src/front/Lexer.cpp"
yy27:
	++cursor;
#line 218 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::ColonEq; }
#line 532 "src/front/Lexer.cpp"
yy28:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'o': goto yy36;
		default: goto yy17;
	}
yy29:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 't': goto yy37;
		default: goto yy17;
	}
yy30:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'l': goto yy39;
		default: goto yy17;
	}
yy31:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'l': goto yy41;
		default: goto yy17;
	}
yy32:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy33;
	}
yy33:
#line 212 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Fn; }
#line 632 "src/front/Lexer.cpp"
yy34:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'l': goto yy42;
		default: goto yy17;
	}
yy35:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'u': goto yy44;
		default: goto yy17;
	}
yy36:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'l': goto yy45;
		default: goto yy17;
	}
yy37:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy38;
	}
yy38:
#line 207 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::IntType; }
#line 725 "src/front/Lexer.cpp"
yy39:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy40;
	}
yy40:
#line 206 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::NilType; }
#line 797 "src/front/Lexer.cpp"
yy41:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 's': goto yy47;
		default: goto yy17;
	}
yy42:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy43;
	}
yy43:
#line 205 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Nil; }
#line 876 "src/front/Lexer.cpp"
yy44:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'e': goto yy48;
		default: goto yy17;
	}
yy45:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy46;
	}
yy46:
#line 210 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::BoolType; }
#line 955 "src/front/Lexer.cpp"
yy47:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'e': goto yy50;
		default: goto yy17;
	}
yy48:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy49;
	}
yy49:
#line 208 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::True; }
#line 1034 "src/front/Lexer.cpp"
yy50:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy51;
	}
yy51:
#line 209 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::False; }
#line 1106 "src/front/Lexer.cpp"
yy52:
#line 230 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::End; }
#line 1110 "src/front/Lexer.cpp"
}
#line 231 "src/front/Lexer.re"

        }
    }
    // NOLINTEND(cppcoreguidelines-avoid-goto)
}
