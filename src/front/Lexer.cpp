/* Generated by re2c 3.0 on Thu Aug 18 09:45:52 2022 */
#line 1 "src/front/Lexer.re"

#include "front/Lexer.h"

namespace pink {
    Lexer::Lexer()
        : loc(), buffer()
    {
        end = cursor = marker = token = buffer.end();
    }

    Lexer::Lexer(std::string& buf)
        : loc(), buffer(buf)
    {
        end = buffer.end();
        cursor = marker = token = buffer.begin();
    }

    std::string& Lexer::GetBuf()
    {
      return buffer;
    }

    void Lexer::SetBuf(std::string& buf)
    {
        buffer = buf;
        end = buffer.end();
        cursor = marker = token = buffer.begin();
    }

    void Lexer::AppendBuf(std::string& buf)
    {
      // this procedure modifies the buffer we are currently parsing 
      // by appending the text passed onto it.
      // normally this is inadvisable, because if the string being 
      // appened onto needs to reallocate its internal buffer to
      // accomidate the new characters then any iterators into 
      // said buffer will be invalidated, and we will not keep our 
      // location within the buffer. this is a problem, because we 
      // only want to add new text to lex, we don't want to destroy
      // our position within the array. so we can keep lexing where 
      // we left off. 
      // to solve this problem we are going to take advantage of the 
      // fact that when we perform the append operation, the original 
      // text, and position of said text within the new buffer will 
      // be identical to what it was before the append operation.
      // this is because the append operation does not modify the 
      // existing text, or its relative position within the buffer,
      // it only adds new text after the end.
      // thus if we store the distance that each iterator is into the 
      // current buffer, after the append, we can 'restore' the position 
      // of the iterators within the new buffer containing the 
      // old text and the appended new text.
      
      // save the relative offsets of each iterator.
      int cursor_dist = Distance(buffer, cursor);
      int marker_dist = Distance(buffer, marker);
      int token_dist  = Distance(buffer, token);
      
      buffer += buf; // perform the append operation, which may invalidate the iterators
      
      // construct new valid iterators, at their old relative offsets within the new string.
      end    = buffer.end();
      cursor = SeekIterator(buffer, cursor_dist);
      marker = SeekIterator(buffer, marker_dist);
      token  = SeekIterator(buffer, token_dist);
    }

    void Lexer::Reset()
    {
        buffer.clear();
        end = cursor = marker = token = buffer.end();
    }
    
    bool Lexer::EndOfInput()
    {
      return (end - cursor) == 0;
    }

    /*
        This routine works great for single line
        inputs, but should be tested against multi-line
        inputs for a more rigourous compiler. #TODO
    */
    void Lexer::UpdateLoc()
    {
    /*
        since token points to the beginning of the
        current token being lexed, and cursor points
        to the current position of the lexer,
        after a token has been lexed from the buffer,
        it sits between [cursor, token], and the
        string iterator operator -() lets us compute
        that distance in chars directly.

        theoretically we could swap string for wstring
        to support unicode. I think this would still
        work, but i'm not 100% sure about that.
    */
        size_t length = cursor - token;

        loc.firstLine   = loc.lastLine;
        loc.firstColumn = loc.lastColumn;

        for (size_t i = 0; i < length; i++)
        {
            if (token[i] == '\n')
            {
                loc.lastLine   += 1;
                loc.lastColumn += 1;
            }
            else
            {
                loc.lastColumn += 1;
            }
        }
    }

    int Lexer::Distance(std::string& buf, std::string::iterator it)
    {
      // the iterator points to somewhere in the array of characters,
      // the beginning of the buffer is somewhere in memory. since the 
      // data structure is a string, we know that the elements of memory 
      // between the beginning and it are also members of this string.
      // since the iterators are also just pointers, and pointers are 
      // just integers, we can subtract the farther point, it, from the 
      // closer point, buf.begin(), this results in the distance between the
      // two iterators. that is the number of characters within the string 
      // between the beginning and the iterator it.
      return it - buf.begin();
    }

    std::string::iterator Lexer::SeekIterator(std::string& buf, int distance)
    {
      // return an iterator into the string some distance into the string.
      return buf.begin() + distance;
    }


    /*
        token points to the beginning of the
        current token being lexed, and cursor points
        to the current position of the lexer,
        so the last token that was lexed is sitting
        between those two positions.

        Therefore we can use the string constructor
        taking a two iterators to construct the
        string from the characters from between that range.
    */
    std::string Lexer::yytxt()
    {
        return std::string(token, cursor);
    }

    Location Lexer::yyloc()
    {
        return loc;
    }


    /*
        These are the definitions of the parsing
        primitives that re2c uses, such that we
        can interoperate between c++ and re2c
        
        # TODO: i think this regex will allow for identifiers 
        	like: this-is-an-ident, follow-with-hyphen
        	but dissallow idents like:
        		-unop-application-not-an-ident,
        		binop-application-not-an-ident- more-text
        		 
        id=[a-zA-Z_]([-]?[a-zA-Z0-9_])*;
    */
    #line 192 "src/front/Lexer.re"


	// NOLINTBEGIN(cppcoreguidelines-avoid-goto)
	// re2c uses gotos to implement the lexer, as all of the 
	// gotos are from generated code, we are trusting re2c to 
	// use gotos in a safe and sane way here.
    Token Lexer::yylex()
    {
        while (1)
        {
            token = cursor;
         
            
#line 191 "src/front/Lexer.cpp"
{
	char yych;
	yych = *cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy2;
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '/':
		case '<':
		case '>':
		case '@':
		case '^':
		case '|':
		case '~': goto yy4;
		case '(': goto yy6;
		case ')': goto yy7;
		case ',': goto yy8;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy9;
		case ':': goto yy11;
		case ';': goto yy13;
		case '=': goto yy14;
		case 'A':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'g':
		case 'h':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		case 'B': goto yy19;
		case 'I': goto yy20;
		case 'N': goto yy21;
		case '[': goto yy22;
		case ']': goto yy23;
		case 'e': goto yy24;
		case 'f': goto yy25;
		case 'i': goto yy26;
		case 'n': goto yy27;
		case 't': goto yy28;
		case '{': goto yy29;
		case '}': goto yy30;
		default:
			if (end <= cursor) goto yy66;
			goto yy1;
	}
yy1:
	++cursor;
#line 234 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Error; }
#line 294 "src/front/Lexer.cpp"
yy2:
	yych = *++cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy2;
		default: goto yy3;
	}
yy3:
#line 233 "src/front/Lexer.re"
	{ UpdateLoc(); continue; }
#line 306 "src/front/Lexer.cpp"
yy4:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '/':
		case '<':
		case '=':
		case '>':
		case '@':
		case '^':
		case '|':
		case '~': goto yy4;
		default: goto yy5;
	}
yy5:
#line 230 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Op; }
#line 330 "src/front/Lexer.cpp"
yy6:
	++cursor;
#line 222 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LParen; }
#line 335 "src/front/Lexer.cpp"
yy7:
	++cursor;
#line 223 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RParen; }
#line 340 "src/front/Lexer.cpp"
yy8:
	++cursor;
#line 217 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Comma; }
#line 345 "src/front/Lexer.cpp"
yy9:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy9;
		default: goto yy10;
	}
yy10:
#line 231 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Int; }
#line 364 "src/front/Lexer.cpp"
yy11:
	yych = *++cursor;
	switch (yych) {
		case '=': goto yy31;
		default: goto yy12;
	}
yy12:
#line 219 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Colon; }
#line 374 "src/front/Lexer.cpp"
yy13:
	++cursor;
#line 218 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Semicolon; }
#line 379 "src/front/Lexer.cpp"
yy14:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '/':
		case '<':
		case '=':
		case '>':
		case '@':
		case '^':
		case '|':
		case '~': goto yy4;
		default: goto yy15;
	}
yy15:
#line 220 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Equals; }
#line 403 "src/front/Lexer.cpp"
yy16:
	yych = *++cursor;
yy17:
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy18;
	}
yy18:
#line 229 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Id; }
#line 476 "src/front/Lexer.cpp"
yy19:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'o': goto yy32;
		default: goto yy17;
	}
yy20:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'n': goto yy33;
		default: goto yy17;
	}
yy21:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'i': goto yy34;
		default: goto yy17;
	}
yy22:
	++cursor;
#line 226 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LBracket; }
#line 502 "src/front/Lexer.cpp"
yy23:
	++cursor;
#line 227 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RBracket; }
#line 507 "src/front/Lexer.cpp"
yy24:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'l': goto yy35;
		default: goto yy17;
	}
yy25:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'a': goto yy36;
		case 'n': goto yy37;
		default: goto yy17;
	}
yy26:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'f': goto yy39;
		default: goto yy17;
	}
yy27:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'i': goto yy41;
		default: goto yy17;
	}
yy28:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'h': goto yy42;
		case 'r': goto yy43;
		default: goto yy17;
	}
yy29:
	++cursor;
#line 224 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LBrace; }
#line 549 "src/front/Lexer.cpp"
yy30:
	++cursor;
#line 225 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RBrace; }
#line 554 "src/front/Lexer.cpp"
yy31:
	++cursor;
#line 221 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::ColonEq; }
#line 559 "src/front/Lexer.cpp"
yy32:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'o': goto yy44;
		default: goto yy17;
	}
yy33:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 't': goto yy45;
		default: goto yy17;
	}
yy34:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'l': goto yy47;
		default: goto yy17;
	}
yy35:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 's': goto yy49;
		default: goto yy17;
	}
yy36:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'l': goto yy50;
		default: goto yy17;
	}
yy37:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy38;
	}
yy38:
#line 212 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Fn; }
#line 666 "src/front/Lexer.cpp"
yy39:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy40;
	}
yy40:
#line 213 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::If; }
#line 738 "src/front/Lexer.cpp"
yy41:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'l': goto yy51;
		default: goto yy17;
	}
yy42:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'e': goto yy53;
		default: goto yy17;
	}
yy43:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'u': goto yy54;
		default: goto yy17;
	}
yy44:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'l': goto yy55;
		default: goto yy17;
	}
yy45:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy46;
	}
yy46:
#line 207 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::IntType; }
#line 838 "src/front/Lexer.cpp"
yy47:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy48;
	}
yy48:
#line 206 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::NilType; }
#line 910 "src/front/Lexer.cpp"
yy49:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'e': goto yy57;
		default: goto yy17;
	}
yy50:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 's': goto yy59;
		default: goto yy17;
	}
yy51:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy52;
	}
yy52:
#line 205 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Nil; }
#line 996 "src/front/Lexer.cpp"
yy53:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'n': goto yy60;
		default: goto yy17;
	}
yy54:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'e': goto yy62;
		default: goto yy17;
	}
yy55:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy56;
	}
yy56:
#line 210 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::BoolType; }
#line 1082 "src/front/Lexer.cpp"
yy57:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy58;
	}
yy58:
#line 215 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Else; }
#line 1154 "src/front/Lexer.cpp"
yy59:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy18;
		case 'e': goto yy64;
		default: goto yy17;
	}
yy60:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy61;
	}
yy61:
#line 214 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Then; }
#line 1233 "src/front/Lexer.cpp"
yy62:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy63;
	}
yy63:
#line 208 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::True; }
#line 1305 "src/front/Lexer.cpp"
yy64:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy16;
		default: goto yy65;
	}
yy65:
#line 209 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::False; }
#line 1377 "src/front/Lexer.cpp"
yy66:
#line 235 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::End; }
#line 1381 "src/front/Lexer.cpp"
}
#line 236 "src/front/Lexer.re"

        }
    }
    // NOLINTEND(cppcoreguidelines-avoid-goto)
}
