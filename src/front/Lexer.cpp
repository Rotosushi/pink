/* Generated by re2c 3.0 on Fri Jun 17 08:18:44 2022 */
#line 1 "src/front/Lexer.re"

#include "front/Lexer.h"

namespace pink {
    Lexer::Lexer()
        : loc(), buffer()
    {
        end = cursor = marker = token = buffer.end();
    }

    Lexer::Lexer(std::string& buf)
        : loc(), buffer(buf)
    {
        end = buffer.end();
        cursor = marker = token = buffer.begin();
    }

    void Lexer::SetBuf(std::string& buf)
    {
        buffer = buf;
        end = buffer.end();
        cursor = marker = token = buffer.begin();
    }

    void Lexer::Reset()
    {
        buffer.clear();
        end = cursor = marker = token = buffer.end();
    }

    /*
        This routine works great for single line
        inputs, but should be tested against multi-line
        inputs for a more rigourous compiler. #TODO
    */
    void Lexer::UpdateLoc()
    {
    /*
        since token points to the beginning of the
        current token being lexed, and cursor points
        to the current position of the lexer,
        after a token has been lexed from the buffer,
        it sits between [cursor, token], and the
        string iterator operator -() lets us compute
        that distance in chars directly.

        theoretically we could swap string for wstring
        to support unicode. I think this would still
        work, but i'm not 100% sure about that.
    */
        size_t length = cursor - token;

        loc.firstLine   = loc.lastLine;
        loc.firstColumn = loc.lastColumn;

        for (size_t i = 0; i < length; i++)
        {
            if (token[i] == '\n')
            {
                loc.lastLine   += 1;
                loc.lastColumn += 1;
            }
            else
            {
                loc.lastColumn += 1;
            }
        }
    }

    /*
        token points to the beginning of the
        current token being lexed, and cursor points
        to the current position of the lexer,
        so the last token that was lexed is sitting
        between those two positions.

        Therefore we can use the string constructor
        taking a two iterators to construct the
        string from the characters from between that range.
    */
    std::string Lexer::yytxt()
    {
        return std::string(token, cursor);
    }

    Location Lexer::yyloc()
    {
        return loc;
    }


    /*
        These are the definitions of the parsing
        primitives that re2c uses, such that we
        can interoperate between c++ and re2c
        
        # TODO: i think this regex will allow for identifiers 
        	like: this-is-an-ident, follow-with-hyphen
        	but dissallow idents like:
        		-unop-application-not-an-ident,
        		binop-application-not-an-ident- more-text
        		 
        id=[a-zA-Z_]([-]?[a-zA-Z0-9_])*;
    */
    #line 123 "src/front/Lexer.re"


	// NOLINTBEGIN(cppcoreguidelines-avoid-goto)
	// re2c uses gotos to implement the lexer, as all of the 
	// gotos are from generated code, we are trusting re2c to 
	// use gotos in a safe and sane way here.
    Token Lexer::yylex()
    {
        while (1)
        {
            token = cursor;
         
            
#line 122 "src/front/Lexer.cpp"
{
	char yych;
	yych = *cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy2;
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '<':
		case '>':
		case '@':
		case '\\':
		case '^':
		case '|':
		case '~': goto yy3;
		case '(': goto yy5;
		case ')': goto yy6;
		case ',': goto yy7;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy8;
		case ':': goto yy10;
		case ';': goto yy12;
		case '=': goto yy13;
		case 'A':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy15;
		case 'B': goto yy18;
		case 'I': goto yy19;
		case 'N': goto yy20;
		case 'f': goto yy21;
		case 'n': goto yy22;
		case 't': goto yy23;
		case '{': goto yy24;
		case '}': goto yy25;
		default:
			if (end <= cursor) goto yy51;
			goto yy1;
	}
yy1:
	++cursor;
#line 160 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Error; }
#line 223 "src/front/Lexer.cpp"
yy2:
	++cursor;
#line 159 "src/front/Lexer.re"
	{ UpdateLoc(); continue; }
#line 228 "src/front/Lexer.cpp"
yy3:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '<':
		case '=':
		case '>':
		case '@':
		case '\\':
		case '^':
		case '|':
		case '~': goto yy3;
		default: goto yy4;
	}
yy4:
#line 156 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Op; }
#line 252 "src/front/Lexer.cpp"
yy5:
	++cursor;
#line 150 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LParen; }
#line 257 "src/front/Lexer.cpp"
yy6:
	++cursor;
#line 151 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RParen; }
#line 262 "src/front/Lexer.cpp"
yy7:
	++cursor;
#line 145 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Comma; }
#line 267 "src/front/Lexer.cpp"
yy8:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy8;
		default: goto yy9;
	}
yy9:
#line 157 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Int; }
#line 286 "src/front/Lexer.cpp"
yy10:
	yych = *++cursor;
	switch (yych) {
		case '=': goto yy26;
		default: goto yy11;
	}
yy11:
#line 147 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Colon; }
#line 296 "src/front/Lexer.cpp"
yy12:
	++cursor;
#line 146 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Semicolon; }
#line 301 "src/front/Lexer.cpp"
yy13:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '<':
		case '=':
		case '>':
		case '@':
		case '\\':
		case '^':
		case '|':
		case '~': goto yy3;
		default: goto yy14;
	}
yy14:
#line 148 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Equals; }
#line 325 "src/front/Lexer.cpp"
yy15:
	yych = *++cursor;
yy16:
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy15;
		default: goto yy17;
	}
yy17:
#line 155 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Id; }
#line 398 "src/front/Lexer.cpp"
yy18:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'o': goto yy27;
		default: goto yy16;
	}
yy19:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'n': goto yy28;
		default: goto yy16;
	}
yy20:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'i': goto yy29;
		default: goto yy16;
	}
yy21:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'a': goto yy30;
		case 'n': goto yy31;
		default: goto yy16;
	}
yy22:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'i': goto yy33;
		default: goto yy16;
	}
yy23:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'r': goto yy34;
		default: goto yy16;
	}
yy24:
	++cursor;
#line 152 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LBrace; }
#line 446 "src/front/Lexer.cpp"
yy25:
	++cursor;
#line 153 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RBrace; }
#line 451 "src/front/Lexer.cpp"
yy26:
	++cursor;
#line 149 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::ColonEq; }
#line 456 "src/front/Lexer.cpp"
yy27:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'o': goto yy35;
		default: goto yy16;
	}
yy28:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 't': goto yy36;
		default: goto yy16;
	}
yy29:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'l': goto yy38;
		default: goto yy16;
	}
yy30:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'l': goto yy40;
		default: goto yy16;
	}
yy31:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy15;
		default: goto yy32;
	}
yy32:
#line 143 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Fn; }
#line 556 "src/front/Lexer.cpp"
yy33:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'l': goto yy41;
		default: goto yy16;
	}
yy34:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'u': goto yy43;
		default: goto yy16;
	}
yy35:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'l': goto yy44;
		default: goto yy16;
	}
yy36:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy15;
		default: goto yy37;
	}
yy37:
#line 138 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::IntType; }
#line 649 "src/front/Lexer.cpp"
yy38:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy15;
		default: goto yy39;
	}
yy39:
#line 137 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::NilType; }
#line 721 "src/front/Lexer.cpp"
yy40:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 's': goto yy46;
		default: goto yy16;
	}
yy41:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy15;
		default: goto yy42;
	}
yy42:
#line 136 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Nil; }
#line 800 "src/front/Lexer.cpp"
yy43:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'e': goto yy47;
		default: goto yy16;
	}
yy44:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy15;
		default: goto yy45;
	}
yy45:
#line 141 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::BoolType; }
#line 879 "src/front/Lexer.cpp"
yy46:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy17;
		case 'e': goto yy49;
		default: goto yy16;
	}
yy47:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy15;
		default: goto yy48;
	}
yy48:
#line 139 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::True; }
#line 958 "src/front/Lexer.cpp"
yy49:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy15;
		default: goto yy50;
	}
yy50:
#line 140 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::False; }
#line 1030 "src/front/Lexer.cpp"
yy51:
#line 161 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::End; }
#line 1034 "src/front/Lexer.cpp"
}
#line 162 "src/front/Lexer.re"

        }
    }
    // NOLINTEND(cppcoreguidelines-avoid-goto)
}
