/* Generated by re2c 3.0 on Thu Aug 25 10:21:07 2022 */
#line 1 "src/front/Lexer.re"

#include "front/Lexer.h"

namespace pink {
    Lexer::Lexer()
        : loc(), buffer()
    {
        end = cursor = marker = token = buffer.end();
    }

    Lexer::Lexer(std::string& buf)
        : loc(), buffer(buf)
    {
        end = buffer.end();
        cursor = marker = token = buffer.begin();
    }

    std::string& Lexer::GetBuf()
    {
      return buffer;
    }

    void Lexer::SetBuf(std::string& buf)
    {
        buffer = buf;
        end = buffer.end();
        cursor = marker = token = buffer.begin();
    }

    void Lexer::AppendBuf(std::string& buf)
    {
      // this procedure modifies the buffer we are currently parsing 
      // by appending the text passed onto it.
      // normally this is inadvisable, because if the string being 
      // appened onto needs to reallocate its internal buffer to
      // accomidate the new characters then any iterators into 
      // said buffer will be invalidated, and we will not keep our 
      // location within the buffer. this is a problem, because we 
      // only want to add new text to lex, we don't want to destroy
      // our position within the array. so we can keep lexing where 
      // we left off. 
      // to solve this problem we are going to take advantage of the 
      // fact that when we perform the append operation, the original 
      // text, and position of said text within the new buffer will 
      // be identical to what it was before the append operation.
      // this is because the append operation does not modify the 
      // existing text, or its relative position within the buffer,
      // it only adds new text after the end.
      // thus if we store the distance that each iterator is into the 
      // current buffer, after the append, we can 'restore' the position 
      // of the iterators within the new buffer containing the 
      // old text and the appended new text.
      
      // save the relative offsets of each iterator.
      int cursor_dist = Distance(buffer, cursor);
      int marker_dist = Distance(buffer, marker);
      int token_dist  = Distance(buffer, token);
      
      buffer += buf; // perform the append operation, which may invalidate the iterators
      
      // construct new valid iterators, at their old relative offsets within the new string.
      end    = buffer.end();
      cursor = SeekIterator(buffer, cursor_dist);
      marker = SeekIterator(buffer, marker_dist);
      token  = SeekIterator(buffer, token_dist);
    }

    void Lexer::Reset()
    {
        buffer.clear();
        end = cursor = marker = token = buffer.end();
    }
    
    bool Lexer::EndOfInput()
    {
      return (end - cursor) == 0;
    }

    /*
        This routine works great for single line
        inputs, but should be tested against multi-line
        inputs for a more rigourous compiler. #TODO
    */
    void Lexer::UpdateLoc()
    {
    /*
        since token points to the beginning of the
        current token being lexed, and cursor points
        to the current position of the lexer,
        after a token has been lexed from the buffer,
        it sits between [cursor, token], and the
        string iterator operator -() lets us compute
        that distance in chars directly.

        theoretically we could swap string for wstring
        to support unicode. I think this would still
        work, but i'm not 100% sure about that.
    */
        size_t length = cursor - token;

        loc.firstLine   = loc.lastLine;
        loc.firstColumn = loc.lastColumn;

        for (size_t i = 0; i < length; i++)
        {
            if (token[i] == '\n')
            {
                loc.lastLine   += 1;
                loc.lastColumn += 1;
            }
            else
            {
                loc.lastColumn += 1;
            }
        }
    }

    int Lexer::Distance(std::string& buf, std::string::iterator it)
    {
      // the iterator points to somewhere in the array of characters,
      // the beginning of the buffer is somewhere in memory. since the 
      // data structure is a string, we know that the elements of memory 
      // between the beginning and it are also members of this string.
      // since the iterators are also just pointers, and pointers are 
      // just integers, we can subtract the farther point, it, from the 
      // closer point, buf.begin(), this results in the distance between the
      // two iterators. that is the number of characters within the string 
      // between the beginning and the iterator it.
      return it - buf.begin();
    }

    std::string::iterator Lexer::SeekIterator(std::string& buf, int distance)
    {
      // return an iterator into the string some distance into the string.
      return buf.begin() + distance;
    }


    /*
        token points to the beginning of the
        current token being lexed, and cursor points
        to the current position of the lexer,
        so the last token that was lexed is sitting
        between those two positions.

        Therefore we can use the string constructor
        taking a two iterators to construct the
        string from the characters from between that range.
    */
    std::string Lexer::yytxt()
    {
        return std::string(token, cursor);
    }

    Location Lexer::yyloc()
    {
        return loc;
    }


    /*
        These are the definitions of the parsing
        primitives that re2c uses, such that we
        can interoperate between c++ and re2c
        
        # TODO: i think this regex will allow for identifiers 
        	like: this-is-an-ident, follow-with-hyphen
        	but dissallow idents like:
        		-unop-application-not-an-ident,
        		binop-application-not-an-ident- more-text
        		 
        id=[a-zA-Z_]([-]?[a-zA-Z0-9_])*;
    */
    #line 192 "src/front/Lexer.re"


	// NOLINTBEGIN(cppcoreguidelines-avoid-goto)
	// re2c uses gotos to implement the lexer, as all of the 
	// gotos are from generated code, we are trusting re2c to 
	// use gotos in a safe and sane way here.
    Token Lexer::yylex()
    {
        while (1)
        {
            token = cursor;
         
            
#line 191 "src/front/Lexer.cpp"
{
	char yych;
	yych = *cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy2;
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '/':
		case '<':
		case '>':
		case '@':
		case '^':
		case '|':
		case '~': goto yy4;
		case '(': goto yy6;
		case ')': goto yy7;
		case ',': goto yy8;
		case '.': goto yy9;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy10;
		case ':': goto yy12;
		case ';': goto yy14;
		case '=': goto yy15;
		case 'A':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'g':
		case 'h':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 'u':
		case 'v':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		case 'B': goto yy20;
		case 'I': goto yy21;
		case 'N': goto yy22;
		case '[': goto yy23;
		case ']': goto yy24;
		case 'd': goto yy25;
		case 'e': goto yy26;
		case 'f': goto yy27;
		case 'i': goto yy28;
		case 'n': goto yy29;
		case 't': goto yy30;
		case 'w': goto yy31;
		case '{': goto yy32;
		case '}': goto yy33;
		default:
			if (end <= cursor) goto yy76;
			goto yy1;
	}
yy1:
	++cursor;
#line 237 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Error; }
#line 295 "src/front/Lexer.cpp"
yy2:
	yych = *++cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy2;
		default: goto yy3;
	}
yy3:
#line 236 "src/front/Lexer.re"
	{ UpdateLoc(); continue; }
#line 307 "src/front/Lexer.cpp"
yy4:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '/':
		case '<':
		case '=':
		case '>':
		case '@':
		case '^':
		case '|':
		case '~': goto yy4;
		default: goto yy5;
	}
yy5:
#line 233 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Op; }
#line 331 "src/front/Lexer.cpp"
yy6:
	++cursor;
#line 225 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LParen; }
#line 336 "src/front/Lexer.cpp"
yy7:
	++cursor;
#line 226 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RParen; }
#line 341 "src/front/Lexer.cpp"
yy8:
	++cursor;
#line 220 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Comma; }
#line 346 "src/front/Lexer.cpp"
yy9:
	++cursor;
#line 219 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Dot; }
#line 351 "src/front/Lexer.cpp"
yy10:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy10;
		default: goto yy11;
	}
yy11:
#line 234 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Int; }
#line 370 "src/front/Lexer.cpp"
yy12:
	yych = *++cursor;
	switch (yych) {
		case '=': goto yy34;
		default: goto yy13;
	}
yy13:
#line 222 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Colon; }
#line 380 "src/front/Lexer.cpp"
yy14:
	++cursor;
#line 221 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Semicolon; }
#line 385 "src/front/Lexer.cpp"
yy15:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '/':
		case '<':
		case '=':
		case '>':
		case '@':
		case '^':
		case '|':
		case '~': goto yy4;
		default: goto yy16;
	}
yy16:
#line 223 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Equals; }
#line 409 "src/front/Lexer.cpp"
yy17:
	yych = *++cursor;
yy18:
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy19;
	}
yy19:
#line 232 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Id; }
#line 482 "src/front/Lexer.cpp"
yy20:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'o': goto yy35;
		default: goto yy18;
	}
yy21:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'n': goto yy36;
		default: goto yy18;
	}
yy22:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'i': goto yy37;
		default: goto yy18;
	}
yy23:
	++cursor;
#line 229 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LBracket; }
#line 508 "src/front/Lexer.cpp"
yy24:
	++cursor;
#line 230 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RBracket; }
#line 513 "src/front/Lexer.cpp"
yy25:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'o': goto yy38;
		default: goto yy18;
	}
yy26:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy40;
		default: goto yy18;
	}
yy27:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'a': goto yy41;
		case 'n': goto yy42;
		default: goto yy18;
	}
yy28:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'f': goto yy44;
		default: goto yy18;
	}
yy29:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'i': goto yy46;
		default: goto yy18;
	}
yy30:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'h': goto yy47;
		case 'r': goto yy48;
		default: goto yy18;
	}
yy31:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'h': goto yy49;
		default: goto yy18;
	}
yy32:
	++cursor;
#line 227 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::LBrace; }
#line 569 "src/front/Lexer.cpp"
yy33:
	++cursor;
#line 228 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::RBrace; }
#line 574 "src/front/Lexer.cpp"
yy34:
	++cursor;
#line 224 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::ColonEq; }
#line 579 "src/front/Lexer.cpp"
yy35:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'o': goto yy50;
		default: goto yy18;
	}
yy36:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 't': goto yy51;
		default: goto yy18;
	}
yy37:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy53;
		default: goto yy18;
	}
yy38:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy39;
	}
yy39:
#line 217 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Do; }
#line 672 "src/front/Lexer.cpp"
yy40:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 's': goto yy55;
		default: goto yy18;
	}
yy41:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy56;
		default: goto yy18;
	}
yy42:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy43;
	}
yy43:
#line 212 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Fn; }
#line 758 "src/front/Lexer.cpp"
yy44:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy45;
	}
yy45:
#line 213 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::If; }
#line 830 "src/front/Lexer.cpp"
yy46:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy57;
		default: goto yy18;
	}
yy47:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy59;
		default: goto yy18;
	}
yy48:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'u': goto yy60;
		default: goto yy18;
	}
yy49:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'i': goto yy61;
		default: goto yy18;
	}
yy50:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy62;
		default: goto yy18;
	}
yy51:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy52;
	}
yy52:
#line 207 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::IntType; }
#line 937 "src/front/Lexer.cpp"
yy53:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy54;
	}
yy54:
#line 206 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::NilType; }
#line 1009 "src/front/Lexer.cpp"
yy55:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy64;
		default: goto yy18;
	}
yy56:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 's': goto yy66;
		default: goto yy18;
	}
yy57:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy58;
	}
yy58:
#line 205 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Nil; }
#line 1095 "src/front/Lexer.cpp"
yy59:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'n': goto yy67;
		default: goto yy18;
	}
yy60:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy69;
		default: goto yy18;
	}
yy61:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy71;
		default: goto yy18;
	}
yy62:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy63;
	}
yy63:
#line 210 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::BoolType; }
#line 1188 "src/front/Lexer.cpp"
yy64:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy65;
	}
yy65:
#line 215 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Else; }
#line 1260 "src/front/Lexer.cpp"
yy66:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy72;
		default: goto yy18;
	}
yy67:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy68;
	}
yy68:
#line 214 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::Then; }
#line 1339 "src/front/Lexer.cpp"
yy69:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy70;
	}
yy70:
#line 208 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::True; }
#line 1411 "src/front/Lexer.cpp"
yy71:
	yych = *++cursor;
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy74;
		default: goto yy18;
	}
yy72:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy73;
	}
yy73:
#line 209 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::False; }
#line 1490 "src/front/Lexer.cpp"
yy74:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		default: goto yy75;
	}
yy75:
#line 216 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::While; }
#line 1562 "src/front/Lexer.cpp"
yy76:
#line 238 "src/front/Lexer.re"
	{ UpdateLoc(); return Token::End; }
#line 1566 "src/front/Lexer.cpp"
}
#line 239 "src/front/Lexer.re"

        }
    }
    // NOLINTEND(cppcoreguidelines-avoid-goto)
}
