/* Generated by re2c 3.0 on Mon Jan  9 12:31:56 2023 */
#line 1 "source/front/Lexer.re"
#include <iterator> // std::distance

#include "front/Lexer.h"

namespace pink {
Lexer::Lexer() : loc(1, 0, 1, 0) {
  end = cursor = marker = token = buffer.end();
}

Lexer::Lexer(std::string &buf) : loc(1, 0, 1, 0), buffer(buf) {
  end = buffer.end();
  cursor = marker = token = buffer.begin();
}

auto Lexer::GetBuf() const -> const std::string & { return buffer; }

void Lexer::SetBuf(std::string &buf) {
  buffer = buf;
  end = buffer.end();
  cursor = marker = token = buffer.begin();
}

void Lexer::AppendBuf(const char *txt) {
  // save the relative offsets of each iterator.
  auto cursor_dist = std::distance(buffer.begin(), cursor);
  auto marker_dist = std::distance(buffer.begin(), marker);
  auto token_dist = std::distance(buffer.begin(), token);

  buffer +=
      txt; // perform the append operation, which may invalidate the iterators

  // construct new valid iterators, at their old relative offsets within the new
  // string.
  end = buffer.end();
  cursor = buffer.begin() + cursor_dist;
  marker = buffer.begin() + marker_dist;
  token = buffer.begin() + token_dist;
}

void Lexer::AppendBuf(std::string &buf) {
  // this procedure modifies the buffer we are currently parsing
  // by appending the text passed onto it.
  // normally this is inadvisable, because if the string being
  // appened onto needs to reallocate its internal buffer to
  // accomidate the new characters then any iterators into
  // said buffer will be invalidated, and we will not keep our
  // location within the buffer. this is a problem, because we
  // only want to add new text to lex, we don't want to destroy
  // our position within the array. so we can keep lexing where
  // we left off.
  // to solve this problem we are going to take advantage of the
  // fact that when we perform the append operation the relative
  // position of the original text within the new buffer will
  // be identical to what it was before the append operation.
  // it is only the memory addresses that have been changed.
  // this is because the append operation does not modify the
  // existing text, or its relative position within the buffer,
  // it only adds new text after the end.
  // thus if we store the index that each iterator is into the
  // current buffer, after the append, we can 'restore' the position
  // of the iterators within the new buffer containing the
  // old text and the appended new text.

  // save the relative offsets of each iterator.
  auto cursor_dist = std::distance(buffer.begin(), cursor);
  auto marker_dist = std::distance(buffer.begin(), marker);
  auto token_dist = std::distance(buffer.begin(), token);

  // perform the append operation, which may invalidate the iterators
  buffer += buf;

  // construct new iterators at the relative offsets within the new string.
  end = buffer.end();
  cursor = buffer.begin() + cursor_dist;
  marker = buffer.begin() + marker_dist;
  token = buffer.begin() + token_dist;
}

void Lexer::Reset() {
  loc = {1, 0, 1, 0};
  buffer.clear();
  end = cursor = marker = token = buffer.end();
}

auto Lexer::EndOfInput() const -> bool { return (end - cursor) == 0; }

void Lexer::UpdateLoc() {
  auto length = cursor - token;

  loc.firstLine = loc.lastLine;
  loc.firstColumn = loc.lastColumn;

  for (long i = 0; i < length; i++) {
    if (token[i] == '\n') {
      loc.lastLine += 1;
      loc.lastColumn = loc.firstColumn = 0;
    } else {
      loc.lastColumn += 1;
    }
  }
}

/*
    token points to the beginning of the
    current token being lexed, and cursor points
    to the current position of the lexer,
    so the last token that was lexed is sitting
    between those two positions.

    Therefore we can use the string constructor
    taking a two iterators to construct the
    string from the characters from between that range.
*/
auto Lexer::yytxt() -> std::string { return {token, cursor}; }

auto Lexer::yyloc() -> Location { return loc; }

/*
    These are the definitions of the parsing
    primitives that re2c uses, such that we
    can interoperate between c++ and re2c

    #TODO: i think this regex will allow for identifiers
            like: this-is-an-ident, follow-with-hyphen
            but parse identifierss like:
                    -unop-application-of-an-identifier,
                    binop-application-of-an-identifier- more-text

    hyphen-id = id ('-' id)+;

    #TODO and this regex will allow us to lex
    fully qualified identifiers when we want to
    add namespaces to the language.

    full-id = id ("::" id)+;
*/
#line 156 "source/front/Lexer.re"


// NOLINTBEGIN(cppcoreguidelines-avoid-goto)
// #REASON: re2c uses gotos to implement the lexer and as all of the
// gotos are from generated code we are trusting re2c to
// use gotos in a safe and sane way here.
auto Lexer::yylex() -> Token {
  while (true) {
    token = cursor;

    
#line 152 "source/front/Lexer.cpp"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy2;
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '/':
		case '<':
		case '>':
		case '@':
		case '^':
		case '|':
		case '~': goto yy4;
		case '(': goto yy6;
		case ')': goto yy7;
		case ',': goto yy8;
		case '.': goto yy9;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy10;
		case ':': goto yy12;
		case ';': goto yy14;
		case '=': goto yy15;
		case 'A':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'O':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'g':
		case 'h':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 'u':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		case 'B': goto yy20;
		case 'I': goto yy21;
		case 'N': goto yy22;
		case 'P': goto yy23;
		case '[': goto yy24;
		case ']': goto yy25;
		case 'd': goto yy26;
		case 'e': goto yy27;
		case 'f': goto yy28;
		case 'i': goto yy29;
		case 'n': goto yy30;
		case 't': goto yy31;
		case 'v': goto yy32;
		case 'w': goto yy33;
		case '{': goto yy34;
		case '}': goto yy35;
		default:
			if (end <= cursor) goto yy96;
			goto yy1;
	}
yy1:
	++cursor;
#line 202 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Error; }
#line 257 "source/front/Lexer.cpp"
yy2:
	yych = *++cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy2;
		default: goto yy3;
	}
yy3:
#line 201 "source/front/Lexer.re"
	{ UpdateLoc(); continue; }
#line 269 "source/front/Lexer.cpp"
yy4:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '/':
		case '<':
		case '=':
		case '>':
		case '@':
		case '^':
		case '|':
		case '~': goto yy4;
		default: goto yy5;
	}
yy5:
#line 198 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Op; }
#line 293 "source/front/Lexer.cpp"
yy6:
	++cursor;
#line 189 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::LParen; }
#line 298 "source/front/Lexer.cpp"
yy7:
	++cursor;
#line 190 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::RParen; }
#line 303 "source/front/Lexer.cpp"
yy8:
	++cursor;
#line 184 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Comma; }
#line 308 "source/front/Lexer.cpp"
yy9:
	++cursor;
#line 183 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Dot; }
#line 313 "source/front/Lexer.cpp"
yy10:
	yych = *++cursor;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy10;
		default: goto yy11;
	}
yy11:
#line 199 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Integer; }
#line 332 "source/front/Lexer.cpp"
yy12:
	yych = *++cursor;
	switch (yych) {
		case '=': goto yy36;
		default: goto yy13;
	}
yy13:
#line 186 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Colon; }
#line 342 "source/front/Lexer.cpp"
yy14:
	++cursor;
#line 185 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Semicolon;}
#line 347 "source/front/Lexer.cpp"
yy15:
	yych = *++cursor;
	switch (yych) {
		case '!':
		case '$':
		case '%':
		case '&':
		case '*':
		case '+':
		case '-':
		case '/':
		case '<':
		case '=':
		case '>':
		case '@':
		case '^':
		case '|':
		case '~': goto yy4;
		default: goto yy16;
	}
yy16:
#line 187 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Equals; }
#line 371 "source/front/Lexer.cpp"
yy17:
	yyaccept = 0;
	yych = *(marker = ++cursor);
yy18:
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy17;
		case ':': goto yy37;
		default: goto yy19;
	}
yy19:
#line 196 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Id; }
#line 446 "source/front/Lexer.cpp"
yy20:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'o': goto yy39;
		default: goto yy18;
	}
yy21:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'n': goto yy40;
		default: goto yy18;
	}
yy22:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'i': goto yy41;
		default: goto yy18;
	}
yy23:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 't': goto yy42;
		default: goto yy18;
	}
yy24:
	++cursor;
#line 193 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::LBracket; }
#line 483 "source/front/Lexer.cpp"
yy25:
	++cursor;
#line 194 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::RBracket; }
#line 488 "source/front/Lexer.cpp"
yy26:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'o': goto yy43;
		default: goto yy18;
	}
yy27:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy45;
		default: goto yy18;
	}
yy28:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'a': goto yy46;
		case 'n': goto yy47;
		default: goto yy18;
	}
yy29:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'f': goto yy49;
		default: goto yy18;
	}
yy30:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'i': goto yy51;
		default: goto yy18;
	}
yy31:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'h': goto yy52;
		case 'r': goto yy53;
		default: goto yy18;
	}
yy32:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'a': goto yy54;
		default: goto yy18;
	}
yy33:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'h': goto yy55;
		default: goto yy18;
	}
yy34:
	++cursor;
#line 191 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::LBrace; }
#line 559 "source/front/Lexer.cpp"
yy35:
	++cursor;
#line 192 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::RBrace; }
#line 564 "source/front/Lexer.cpp"
yy36:
	++cursor;
#line 188 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::ColonEq; }
#line 569 "source/front/Lexer.cpp"
yy37:
	yych = *++cursor;
	switch (yych) {
		case ':': goto yy56;
		default: goto yy38;
	}
yy38:
	cursor = marker;
	switch (yyaccept) {
		case 0: goto yy19;
		case 1: goto yy44;
		case 2: goto yy48;
		case 3: goto yy50;
		case 4: goto yy60;
		case 5: goto yy62;
		case 6: goto yy66;
		case 7: goto yy70;
		case 8: goto yy73;
		case 9: goto yy77;
		case 10: goto yy80;
		case 11: goto yy82;
		case 12: goto yy87;
		case 13: goto yy89;
		case 14: goto yy93;
		default: goto yy95;
	}
yy39:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'o': goto yy57;
		default: goto yy18;
	}
yy40:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 't': goto yy58;
		default: goto yy18;
	}
yy41:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy59;
		default: goto yy18;
	}
yy42:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'r': goto yy61;
		default: goto yy18;
	}
yy43:
	yyaccept = 1;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy44;
	}
yy44:
#line 181 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Do; }
#line 701 "source/front/Lexer.cpp"
yy45:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 's': goto yy63;
		default: goto yy18;
	}
yy46:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy64;
		default: goto yy18;
	}
yy47:
	yyaccept = 2;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy48;
	}
yy48:
#line 175 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Fn; }
#line 791 "source/front/Lexer.cpp"
yy49:
	yyaccept = 3;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy50;
	}
yy50:
#line 177 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::If; }
#line 865 "source/front/Lexer.cpp"
yy51:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy65;
		default: goto yy18;
	}
yy52:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy67;
		default: goto yy18;
	}
yy53:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'u': goto yy68;
		default: goto yy18;
	}
yy54:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'r': goto yy69;
		default: goto yy18;
	}
yy55:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'i': goto yy71;
		default: goto yy18;
	}
yy56:
	yych = *++cursor;
	switch (yych) {
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy72;
		default: goto yy38;
	}
yy57:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy74;
		default: goto yy18;
	}
yy58:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy75;
		default: goto yy18;
	}
yy59:
	yyaccept = 4;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy60;
	}
yy60:
#line 168 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::NilType; }
#line 1053 "source/front/Lexer.cpp"
yy61:
	yyaccept = 5;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy62;
	}
yy62:
#line 173 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Ptr; }
#line 1127 "source/front/Lexer.cpp"
yy63:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy76;
		default: goto yy18;
	}
yy64:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 's': goto yy78;
		default: goto yy18;
	}
yy65:
	yyaccept = 6;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy66;
	}
yy66:
#line 167 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Nil; }
#line 1217 "source/front/Lexer.cpp"
yy67:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'n': goto yy79;
		default: goto yy18;
	}
yy68:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy81;
		default: goto yy18;
	}
yy69:
	yyaccept = 7;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy70;
	}
yy70:
#line 176 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Var; }
#line 1307 "source/front/Lexer.cpp"
yy71:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'l': goto yy83;
		default: goto yy18;
	}
yy72:
	yyaccept = 8;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy72;
		case ':': goto yy37;
		default: goto yy73;
	}
yy73:
#line 197 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::FullyQualifiedId; }
#line 1389 "source/front/Lexer.cpp"
yy74:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy84;
		default: goto yy18;
	}
yy75:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'g': goto yy85;
		default: goto yy18;
	}
yy76:
	yyaccept = 9;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy77;
	}
yy77:
#line 179 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Else; }
#line 1479 "source/front/Lexer.cpp"
yy78:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy86;
		default: goto yy18;
	}
yy79:
	yyaccept = 10;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy80;
	}
yy80:
#line 178 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::Then; }
#line 1561 "source/front/Lexer.cpp"
yy81:
	yyaccept = 11;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy82;
	}
yy82:
#line 170 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::True; }
#line 1635 "source/front/Lexer.cpp"
yy83:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy88;
		default: goto yy18;
	}
yy84:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'a': goto yy90;
		default: goto yy18;
	}
yy85:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'e': goto yy91;
		default: goto yy18;
	}
yy86:
	yyaccept = 12;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy87;
	}
yy87:
#line 171 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::False; }
#line 1733 "source/front/Lexer.cpp"
yy88:
	yyaccept = 13;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy89;
	}
yy89:
#line 180 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::While; }
#line 1807 "source/front/Lexer.cpp"
yy90:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'n': goto yy92;
		default: goto yy18;
	}
yy91:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
		case 0x00: goto yy19;
		case 'r': goto yy94;
		default: goto yy18;
	}
yy92:
	yyaccept = 14;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy93;
	}
yy93:
#line 172 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::BooleanType; }
#line 1897 "source/front/Lexer.cpp"
yy94:
	yyaccept = 15;
	yych = *(marker = ++cursor);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case ':':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy18;
		default: goto yy95;
	}
yy95:
#line 169 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::IntegerType; }
#line 1971 "source/front/Lexer.cpp"
yy96:
#line 203 "source/front/Lexer.re"
	{ UpdateLoc(); return Token::End; }
#line 1975 "source/front/Lexer.cpp"
}
#line 204 "source/front/Lexer.re"

  }
}
// NOLINTEND(cppcoreguidelines-avoid-goto)
} // namespace pink
